#version 450

#define WORKGROUP_SIZE 16
layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

#define WIDTH 900
#define HEIGTH 900

layout(push_constant) uniform PushConstantsBlock
{
    float mTime;
} PushConstants;

layout ( binding = 0, r32ui ) uniform uimage2D outImage;

#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)
#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)
#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)
#define hash2x3(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)

// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(1, 0, 0),
    vec3(0, c, -s),
    vec3(0, s, c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, 0, s),
    vec3(0, 1, 0),
    vec3(-s, 0, c)
    );
}

// Rotation matrix around the Z axis.
mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, -s, 0),
    vec3(s, c, 0),
    vec3(0, 0, 1)
    );
}

// Identity matrix.
mat3 identity() {
    return mat3(
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1)
    );
}

int toIntColor( vec3 col )
{
    return int( int( col.r * 255 ) + int( col.g * 255 ) * 255 + int( col.b * 255 ) * 255 * 255 );
}

void drawLine( vec2 a, vec2 b )
{
    vec2 pos = a;
    vec2 direction = normalize( b - a );
    int length = int( distance( a, b ) );

    vec3 colA = vec3( 0, 0.5, 0.5 );
    vec3 colB = vec3( 0.5, 0.9, 0 );
    float colorWeight = .05f;

    for( int i = 0; i < length; i++ )
    {
        pos += direction;

        if( pos.x < 0 || pos.x >= WIDTH * 2 || pos.y < 0 || pos.y >= HEIGTH * 2 )
            continue;

        float t = float( i ) / float( length );
        vec3 col = mix( colA, colB, t );
        col *= colorWeight;

        imageAtomicAdd( outImage, ivec2( pos ), i );
    }
}

vec3 rotate( vec3 pos )
{
    float time = PushConstants.mTime - 2000;
    return rotateY( time / 7000.0f ) * rotateX( time / 10000.0f ) * pos;
}

void main()
{
    vec2 randDir = normalize( vec2( hash2( vec2( gl_GlobalInvocationID.xy ) ) ) * 2.0f - 1.0f );
    float randLength = hash( gl_GlobalInvocationID.xy );
    vec2 xy = randDir * randLength * vec2( WIDTH, HEIGTH );
    vec3 pos = vec3( xy.x, 0, xy.y );
//    ivec2 pos = ivec2( gl_GlobalInvocationID.xy * vec2( WIDTH * 2, HEIGTH * 2 ) + vec2( 500 ) );

    vec2 dir = normalize( vec2( 1, -1) );
//   dir = normalize( vec2( hash2( vec2( gl_GlobalInvocationID.xy ) )  ) );

    vec3 pos2 = pos + vec3( 0, 300, 0 );

    pos = rotate( pos );
    float time = PushConstants.mTime - 2000;
    pos2 = rotateY( time / 20000.0f ) * rotateZ( time / 8000.0f ) * pos2;
//    pos2 = rotate( pos2 );

    pos += vec3( WIDTH, HEIGTH, 0 );
    pos2 += vec3( WIDTH, HEIGTH, 0 );

    drawLine( ivec2( pos.x, pos.y ), ivec2( pos2.x, pos2.y ) );

}